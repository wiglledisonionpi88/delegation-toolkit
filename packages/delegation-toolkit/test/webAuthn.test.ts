import { Buffer as BufferPolyfill } from 'buffer/';
import { expect } from 'chai';
import {
  decodeAbiParameters,
  isHex,
  keccak256,
  encodePacked,
  toHex,
  serializeSignature,
} from 'viem';
import { parseSignature } from 'webauthn-p256';

import {
  MALLEABILITY_THRESHOLD,
  SIGNATURE_ABI_PARAMS,
  encodeDeleGatorSignature,
  splitOnChallenge,
  parseAuthenticatorFlags,
  getResponseTypeLocation,
  FIELD_MODULUS,
} from '../src/webAuthn';

// These signature data values were generated by performing a
// wallet_passkeySignUserOperation call and extracting the values. The specifc
// signature and data should be used for tests where a valid signature is
// required to be decoded. The clientDataJsonPrefix and Suffix components were
// extracted from the base64 client data.

export const validWebAuthnP256SignatureData = {
  keyId: '0x8d39ed41281a2b1d3b61dcc5cd4a0697c6831052b9c91840c62b58caba12ce06',
  signatureBase64:
    'MEUCIE4v5W2lzG9spmgTz1fBtmUMfxuXTY0qjHQmVetQXgBSAiEAzgguCYqG6jbGq5bK05JEWWFif2tlvGhLxlxPBhF6kH0',
  clientDataBase64:
    'eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiYS1yYW5kb20tY2hhbGxlbmdlIiwib3JpZ2luIjoiaHR0cHM6Ly9wYXNza2V5LW9yaWdpbiIsImNyb3NzT3JpZ2luIjpmYWxzZX0=',
  clientDataJsonPrefix: '{"type":"webauthn.get","challenge":"',
  clientDataJsonSuffix:
    '","origin":"https://passkey-origin","crossOrigin":false}',
  authenticatorDataBase64: 'SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA',
  encodedSignature:
    '0xe66a1dfc4ba036bb7cc16ab3a58bdfad55a61c83f6712d948956be9b2f9990f24e2fe56da5cc6f6ca66813cf57c1b6650c7f1b974d8d2a8c742655eb505e005231f7d1f5757915ca395469352c6dbba65b847b42415b36392d5d7bbceae894d400000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000247b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000038222c226f726967696e223a2268747470733a2f2f706173736b65792d6f726967696e222c2263726f73734f726967696e223a66616c73657d0000000000000000',
  rawSignature: {
    r: 35365027457547592025002253927486339786522955686408270765133571076392444887122n,
    s: 22601189888125076292597640100469958197159995280576567101859777909956262008020n,
  },
};

const validWebAuthnData = {
  keyId: '0x8d39ed41281a2b1d3b61dcc5cd4a0697c6831052b9c91840c62b58caba12ce06',
  signature:
    '0x304502204e2fe56da5cc6f6ca66813cf57c1b6650c7f1b974d8d2a8c742655eb505e0052022100ce082e098a86ea36c6ab96cad392445961627f6b65bc684bc65c4f06117a907d',
  encodedSignature:
    '0xe66a1dfc4ba036bb7cc16ab3a58bdfad55a61c83f6712d948956be9b2f9990f24e2fe56da5cc6f6ca66813cf57c1b6650c7f1b974d8d2a8c742655eb505e005231f7d1f5757915ca395469352c6dbba65b847b42415b36392d5d7bbceae894d400000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000247b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000038222c226f726967696e223a2268747470733a2f2f706173736b65792d6f726967696e222c2263726f73734f726967696e223a66616c73657d0000000000000000',
  authenticatorData:
    '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',
  challengeIndex: 23,
  clientDataJSON:
    '{"type":"webauthn.get","challenge":"a-random-challenge","origin":"https://passkey-origin","crossOrigin":false}',
  clientDataJSONPrefix: '{"type":"webauthn.get","challenge":"',
  clientDataJSONSuffix:
    '","origin":"https://passkey-origin","crossOrigin":false}',
  typeIndex: 1,
  userVerificationRequired: true,
} as const;

describe('webAuthn', () => {
  const overwriteAuthenticatorDataFlags = (flags: number) => {
    // we just take the known authenticator data and overwrite the flags
    const authenticatorDataBuffer = BufferPolyfill.from(
      validWebAuthnData.authenticatorData.slice(2),
      'Hex',
    );

    // the 33rd byte (index 32) is the flags byte
    authenticatorDataBuffer[32] = flags;

    return toHex(authenticatorDataBuffer);
  };

  describe('encodeDeleGatorSignature()', () => {
    it('should modulate s values greater than the threshold', () => {
      const { keyId, clientDataJSON, authenticatorData } = validWebAuthnData;
      const rValue = toHex(validWebAuthnP256SignatureData.rawSignature.r);
      const sValue = toHex(
        validWebAuthnP256SignatureData.rawSignature.s + MALLEABILITY_THRESHOLD,
      );
      const yParity = 1;

      const signature = serializeSignature({
        r: rValue,
        s: sValue,
        to: 'hex',
        yParity,
      });

      const encodedDeleGatorSignature = encodeDeleGatorSignature(
        keyId,
        signature,
        clientDataJSON,
        authenticatorData,
      );

      const [, decodedR, decodedS] = decodeAbiParameters(
        SIGNATURE_ABI_PARAMS,
        encodedDeleGatorSignature,
      );

      expect(decodedR).to.equal(validWebAuthnP256SignatureData.rawSignature.r);
      expect(decodedS).to.equal(
        FIELD_MODULUS -
          (validWebAuthnP256SignatureData.rawSignature.s +
            MALLEABILITY_THRESHOLD),
      );
    });

    it('should return a compound signature with the expected components', () => {
      const {
        keyId,
        signature,
        authenticatorData,
        clientDataJSON,
        clientDataJSONPrefix,
        clientDataJSONSuffix,
      } = validWebAuthnData;

      const rawSignature = parseSignature(signature);

      const expectedKeyIdHash = keccak256(encodePacked(['string'], [keyId]));

      const encodedSignature = encodeDeleGatorSignature(
        keyId,
        signature,
        clientDataJSON,
        authenticatorData,
      );

      expect(isHex(encodedSignature)).to.equal(true);

      const [
        keyIdHash,
        rValue,
        sValue,
        decodedAuthenticatorData,
        userValidation,
        clientDataPrefix,
        clientDataSuffix,
        responseTypeLocation,
      ] = decodeAbiParameters(SIGNATURE_ABI_PARAMS, encodedSignature);

      expect(keyIdHash).to.equal(expectedKeyIdHash);
      expect(rValue).to.equal(rawSignature.r);
      expect(sValue).to.equal(rawSignature.s);
      expect(decodedAuthenticatorData).to.equal(authenticatorData);
      expect(userValidation).to.equal(true);
      expect(clientDataPrefix).to.equal(clientDataJSONPrefix);
      expect(clientDataSuffix).to.equal(clientDataJSONSuffix);
      expect(responseTypeLocation).to.equal(1n);
    });

    it('should use the userVerifiedFlag from the authenticator data', () => {
      // authenticator data with all flags set to 0
      const overwrittenAuthenticatorData =
        overwriteAuthenticatorDataFlags(0b00000000);

      const { keyId, signature, clientDataJSON } = validWebAuthnData;

      const encodedSignature = encodeDeleGatorSignature(
        keyId,
        signature,
        clientDataJSON,
        overwrittenAuthenticatorData,
      );

      const [, , , , userValidation] = decodeAbiParameters(
        SIGNATURE_ABI_PARAMS,
        encodedSignature,
      );

      expect(userValidation).to.equal(false);
    });
  });

  describe('SplitOnChallenge()', () => {
    it('should correctly split input on challenge', () => {
      const clientData =
        '{"type":"webauthn.get","challenge":"userOpHash","origin":"example.com"}';
      const expectedPrefix = '{"type":"webauthn.get","challenge":"';
      const expectedSuffix = '","origin":"example.com"}';

      const [prefix, suffix] = splitOnChallenge(clientData);

      expect(prefix).to.equal(expectedPrefix);
      expect(suffix).to.equal(expectedSuffix);
    });

    it('should throw an error if the input is not valid json', () => {
      const invalidJSONClientData = 'not-valid-json';

      expect(() => splitOnChallenge(invalidJSONClientData)).to.throw(
        'No "challenge" found in the input string',
      );
    });

    it('should throw error when "challenge" is not found', () => {
      expect(() => splitOnChallenge('{}')).to.throw(
        'No "challenge" found in the input string',
      );
    });
  });

  describe('getResponseTypeLocation', () => {
    it('should correctly get the response type location', () => {
      const clientData =
        '{"type":"webauthn.get","challenge":"userOpHash","origin":"example.com"}';
      const expectedLocation = 1n;

      const responseTypeLocation = getResponseTypeLocation(clientData);

      expect(responseTypeLocation).to.equal(expectedLocation);
    });

    it('should correct gett the response type location (Firefox clientData response)', () => {
      const clientData =
        '{"challenge":"userOpHash","origin":"example.com","type":"webauthn.get"}';
      const expectedLocation = 49n;

      const responseTypeLocation = getResponseTypeLocation(clientData);
      expect(responseTypeLocation).to.equal(expectedLocation);
    });

    it('should be able to match the response type and the response type fetched from the clientDataJSON using location', () => {
      const clientDataPefix = '{"challenge":"';
      const clientDataSuffix =
        '","origin":"example.com","type":"webauthn.get"}';
      const challenge = 'some-dummy-challenge';

      const clientDataJSON = clientDataPefix + challenge + clientDataSuffix;

      const responseTypeLocation = getResponseTypeLocation(clientDataJSON);
      const responseType = '"type":"webauthn.get"';

      const clientDataResponseTypeSubstring = clientDataJSON.substring(
        Number(responseTypeLocation),
        Number(responseTypeLocation) + responseType.length,
      );

      expect(clientDataResponseTypeSubstring).to.equal(responseType);
    });

    it('should throw an error when "type": is not found', () => {
      expect(() => getResponseTypeLocation('{}')).to.throw(
        'No "type" found in the input string',
      );
    });
  });

  describe('parseAuthenticatorFlags()', () => {
    it('should parse the expected flags from known authenticator data', () => {
      const flags = parseAuthenticatorFlags(
        validWebAuthnData.authenticatorData,
      );

      expect(flags).to.deep.equal({ userVerified: true });
    });

    it('should parse the expected flags from the correct offset in the authenticator data', () => {
      // We set each bit to zero except userVerified (the third least significant bit).
      const flags = 0b00000100;

      const authenticatorData = overwriteAuthenticatorDataFlags(flags);

      const { userVerified } = parseAuthenticatorFlags(authenticatorData);

      expect(userVerified).to.equal(true);
    });

    it('should parse the userVerified flag when it is set to 0', () => {
      // We set each bit to 1 except userVerified (the third least significant bit).
      const flags = 0b11111011;

      const authenticatorData = overwriteAuthenticatorDataFlags(flags);

      const { userVerified } = parseAuthenticatorFlags(authenticatorData);

      expect(userVerified).to.equal(false);
    });
  });
});
